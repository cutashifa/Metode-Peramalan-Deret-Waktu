Model Regresi Data Deret Waktu

1. Import Data dan Library

{r}
library(readxl)
library(lmtest) # Untuk Uji Durbin-Watson
library(orcutt) # Untuk metode Cochrane-Orcutt
library(HoRM)   # Untuk metode Hildreth-Lu

dataipm <- read_excel("C:/Users/user/Documents/Semester 5/Metode Peramalan Deret Waktu/Metode-Peramalan-Deret-Waktu/Pertemuan 2/IPM.xlsx", sheet="Sumbar")
dataipm

2. Membuat Model Awal

{r}
# Membuat model regresi OLS (Ordinary Least Squares)
model_awal <- lm(IPM ~ Tahun, data = dataipm)
summary(model_awal)

Nilai Adjusted R-squared sangat tinggi (0.9751) dan koefisien Tahun sangat signifikan (p-value < 0.001).

3. Diagnosis (Investigasi Sisaan)

3.1. Diagnosis Visual

{r}
# Ambil sisaan dari model
sisaan_awal <- residuals(model_awal)

# Plot sisaan terhadap waktu
plot(dataipm$Tahun, sisaan_awal, type="o", pch=20, col="red",
     main="Plot Sisaan vs Waktu", xlab="Tahun", ylab="Sisaan")
abline(h=0, lty=2) # Garis referensi di y=0

Plot di atas menunjukkan pola yang tidak acak.

3.2. Diagnosis Formal (Uji Durbin-Watson)

$H_0$: Tidak ada autokorelasi. Sisaan saling bebas.

$H_1$: Ada autokorelasi.

{r}
dwtest(model_awal)

p-value yang dihasilkan sangat kecil (0.04476), yaitu di bawah tingkat signifikansi 0.05. Sehingga dapat disimpulkan bahwa kita menolak H0. Model terbukti menderita autokorelasi.

Tahap 4: Penanganan Autokorelasi

Metode 1: Cochrane-Orcutt

Intuisi: Metode ini secara iteratif (berulang-ulang) mencoba menemukan "tingkat penularan" error (disebut rho, ρ), lalu menyesuaikan model sampai autokorelasinya hilang.

Teori Singkat: C-O adalah prosedur iteratif untuk mengestimasi koefisien regresi. Intinya adalah:

Estimasi koefisien autokorelasi sisaan, rho (ρ).

Gunakan ρ untuk mentransformasi variabel dependen (Y) dan independen (X) menjadi:

$Y_t^* =Y_t−\rho Y_{t−1}$

$X_t =X_t−\rho X_{t−1}$

Jalankan regresi OLS pada variabel yang sudah ditransformasi ($Y_t^*$ vs $X_t^*$).

Ulangi langkah 1-3 sampai nilai ρ konvergen.

{r}
model_co <- cochrane.orcutt(model_awal)
summary(model_co)

# rho paling optimum
rho <- model_co$rho
cat("Rho optimum:", rho)

Hasil Penanganan (C-O):

Nilai rho yang diestimasi adalah 0.2206589

Nilai statistik Durbin-Watson baru jauh lebih dekat ke 2, dengan p-value = 0.1167 > 0.05 menunjukkan bahwa autokorelasi sudah berhasil diatasi.

Koefisien (Intercept) dan tahun yang baru merupakan estimasi yang lebih valid dibandingkan model yang awal.

Verifikasi Manual:

{r, warning=FALSE}
ipm.trans <- dataipm$IPM[-1] - dataipm$IPM[-10]*rho

tahun.trans <- dataipm$Tahun[-1] - dataipm$Tahun[-10]*rho
model_co_manual <- lm(ipm.trans~tahun.trans)

b0_co_manual <- coef(model_co_manual)[1]/(1-rho)
b1_co_manual <- coef(model_co_manual)[2]
cat("Koefisien manual Cochrane-Orcutt:\n")
cat("b0:", b0_co_manual, "\n")
cat("b1:", b1_co_manual, "\n")

Dengan cara manual, diperoleh hasil koefisien yang sangat mirip dengan hasil dari fungsi otomatis. (Catatan: Perbedaan kecil mungkin terjadi karena fungsi otomatis melakukan beberapa iterasi).

Metode 2: Hildreth-Lu

Metode ini mencoba berbagai kemungkinan nilai ρ dan memilih satu yang menghasilkan Sum of Squared Errors (SSE) terkecil.

{r}
#Penanganan Autokorelasi Hildreth lu
# Hildreth-Lu
hildreth.lu.func<- function(r, model){
  x <- model.matrix(model)[,-1]
  y <- model.response(model.frame(model))
  n <- length(y)
  t <- 2:n
  y <- y[t]-r*y[t-1]
  x <- x[t]-r*x[t-1]
  
  return(lm(y~x))
}

#Pencariab rho yang meminimumkan SSE
r <- c(seq(0.1,0.9, by= 0.1))
tab <- data.frame("rho" = r, "SSE" = sapply(r, function(i){deviance(hildreth.lu.func(i, model_awal))}))
round(tab, 4)

Pertama-tama akan dicari di mana kira-kira ρ yang menghasilkan SSE minimum. Pada hasil di atas terlihat ρ minimum ketika 0.2. Namun, hasil tersebut masih kurang teliti sehingga akan dicari kembali ρ yang lebih optimum dengan ketelitian yang lebih. Jika sebelumnya jarak antar ρ yang dicari adalah 0.1, kali ini jarak antar ρ adalah 0.001 dan dilakukan pada selang 0.2 sampai dengan 0.5.

{r}
#Rho optimal di sekitar 0.4
rOpt <- seq(0.2,0.5, by= 0.001)
tabOpt <- data.frame("rho" = rOpt, "SSE" = sapply(rOpt, function(i){deviance(hildreth.lu.func(i, model_awal))}))
head(tabOpt[order(tabOpt$SSE),])

{r}
#Grafik SSE optimum
par(mfrow = c(1,1))
plot(tab$SSE ~ tab$rho , type = "l", xlab = "Rho", ylab = "SSE")
abline(v = tabOpt[tabOpt$SSE==min(tabOpt$SSE),"rho"], lty = 2, col="red",lwd=2)
text(x=0.221, y=0.2737269	, labels = "rho=0.221", cex = 0.8)

{r}
model_hl <- hildreth.lu(dataipm$IPM, dataipm$Tahun, rho = 0.221)
summary(model_hl)

{r}
#Transformasi Balik
cat("y = ", coef(model_hl)[1]/(1-0.341), "+", coef(model_hl)[2],"x", sep = "")

{r}
#Deteksi autokorelasi
dwtest(model_hl)

Hasil Penanganan (H-L):

Plot yang dihasilkan secara visual menunjukkan nilai ρ mana yang memiliki nilai SSE terbaik

Nilai p-value = 0.1167 > 0.05 pada statistik uji Durbin-Watson menunjukkan bahwa model Hildreth-Lu berhasil menangani autokorelasi yang terjadi pada model awal.

Tahap 5: Evaluasi Akhir

Mari kita bandingkan SSE dan Statistik Durbin-Watson dari ketiga model untuk melihat seberapa efektif penanganan kita.

{r}
# Menghitung SSE untuk setiap model secara manual
sse_awal <- sum(residuals(model_awal)^2)
sse_co <- sum(residuals(model_co)^2)
sse_hl <- sum(residuals(model_hl)^2)

# Membuat tabel perbandingan
data.frame(
  Metode = c("Model Awal", "Cochrane-Orcutt", "Hildreth-Lu"),
  SSE = c(sse_awal, sse_co, sse_hl),
  DW_Statistic = c(dwtest(model_awal)$statistic, model_co$DW[3], dwtest(model_hl)$statistic)
)

Kesimpulan Investigasi:

Metode Hildreth-Lu berhasil menurunkan SSE model, artinya model tersebut lebih akurat.

Kedua model berhasil menghilangkan autokorelasi, yang ditunjukkan oleh statistik D-W yang mendekati 2.

Model akhir yang seharusnya kita gunakan adalah salah satu dari model yang telah ditangani, karena estimasi koefisien dan uji signifikansinya sekarang jauh lebih dapat dipercaya.

